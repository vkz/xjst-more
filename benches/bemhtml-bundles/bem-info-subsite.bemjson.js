({
    block : 'page',
    title : 'Title of the page',
    favicon : '/favicon.ico',
    head : [
        { elem : 'meta', attrs : { name : 'description', content : '' } },
        { elem : 'meta', attrs : { name : 'viewport', content : 'width=device-width, initial-scale=1' } },
        { elem : 'css', url : '_index.css' }
    ],
    scripts: [{ elem : 'js', url : '_index.js' }],
    mods : { theme : 'islands' },
    mix: { block: 'font', mods: { face: 'ekibastuz' } },
    content : [
        {
            block : 'header',
            content : [
                {
                    block: 'heading',
                    mods: { level: 1 },
                    mix: { block: 'header', elem: 'title' },
                    content: 'i-bem.js'
                },
                {
                    elem: 'info',
                    content: [
                        {
                            block: 'breadcrumbs',
                            content: [
                                {
                                    elem: 'item',
                                    elemMods: { level: 1 },
                                    content: {
                                        block: 'link',
                                        url: '#',
                                        content: 'БЭМ платформа'
                                    }
                                },
                                {
                                    elem: 'item',
                                    elemMods: { level: 2 },
                                    content: {
                                        block: 'link',
                                        url: '#',
                                        content: 'Технологии'
                                    }
                                }
                            ]
                        },
                        {
                            block: 'logo',
                            mix: { block: 'header', elem: 'logo' }
                        }
                    ]
                }
            ]
        },
        {
            block: 'nav',
            content: [
                [
                    {
                        url: '#',
                        content: 'Quick start'
                    },
                    {
                        content: 'Manual'
                    },
                    {
                        url: '#',
                        content: 'Rationale'
                    },
                    {
                        url: '#',
                        content: 'API'
                    },
                    {
                        url: '#',
                        content: 'Playground'
                    },
                    {
                        url: '#',
                        content: 'FAQ'
                    },
                    {
                        url: '#',
                        content: 'Reference'
                    },
                    {
                        url: 'forum',
                        content: 'Форум'
                    }
                ].map(function(item) {
                    return item.url ? {
                        elem: 'item',
                        content: {
                            block: 'link',
                            url: item.url,
                            content: item.content
                        }
                    } : {
                        elem: 'item',
                        elemMods: { current: true },
                        content: item.content
                    };
                }),
                {
                    block: 'search'
                },
                {
                    block: 'link',
                    mix: { block: 'lang-switcher' },
                    content: 'EN'
                }
            ]
        },
        {
            block : 'body',
            content : {
                block: 'content',
                content: [
                    {
                        block: 'post',
                        content: [
                            {
                                elem: 'meta',
                                content: [
                                    {
                                        elem: 'date',
                                        content: 'опубликовано 18 апреля 2014'
                                    },
                                    {
                                        elem: 'author',
                                        content: '<a href="/authors/maslinsky-kirill" class="author author_view_simple link link__control"><span class="author__name">Кирилл Маслинский</span></a>'
                                    },
                                    {
                                        elem: 'tags',
                                        content: [
                                            {
                                                block: 'tag',
                                                content: '<a href="/tags/bem-core" data-bem="{&quot;link&quot;:{}}" class="link link__control i-bem">bem-core</a><span> </span><a href="/tags/i-bem" data-bem="{&quot;link&quot;:{}}" class="link link__control i-bem">i-bem</a><span> </span><a href="/tags/javascript" data-bem="{&quot;link&quot;:{}}" class="link link__control i-bem">javascript</a>'
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                elem: 'title',
                                content: 'i-bem.js: Руководство пользователя'
                            },
                            {
                                content: '<div class="post__title-line flex"><h1 class="post__title"></h1><div class="post__tags"></div></div><div class="post__content"><h1 id="-i-bem-js-:-руководство-пользователя"><em>i-bem.js</em>: Руководство пользователя</h1><h2 id="-i-bem-js-:-javascript-фреймворк-для-бэм"><em>i-bem.js</em>: Javascript-фреймворк для БЭМ</h2><p><em>i-bem.js</em> &mdash; специализированный JavaScript-фреймворк для веб-разработкив рамках <a href="http://ru.bem.info/method/">БЭМ-методологии</a>.</p><p><em>i-bem.js</em> позволяет:</p><ul><li>разрабатывать веб-интерфейс в терминах блоков, элементов, модификаторов;</li><li>описывать логику работы блока в декларативном стиле &mdash; как набор состояний;</li><li>легко интегрировать JavaScript-код с CSS в стиле БЭМ и BEMHTML-шаблонами;</li><li>гибко переопределять поведение библиотечных блоков.</li></ul><p><em>i-bem.js</em> не предназначен:</p><ul><li>для замены фреймворка общего назначения, подобного jQuery.</li></ul><p><strong>Краткий обзор содержания документа</strong>:</p><ul><li><p><a href="#intro">Общие сведения</a> о фреймворке: связь с понятиями БЭМпредметной области, краткое описание модульной структуры фреймворка,шаблонного проекта, инструментов для сборки кода, написанного сиспользованием <em>i-bem.js</em>.</p></li><li><p><a href="#html">Привязка JS-блоков к HTML</a> &mdash; синтаксис указания JS-блоков наHTML-странице, типы соотношения HTML-элементов и JS-блоков.</p></li><li><p><a href="#decl">Декларация блока</a> &mdash; синтаксис описания JS-блоков.</p></li><li><p><a href="#dom">Работа с DOM-деревом</a> &mdash; API для работы с DOM-узлами блоков:элементы, динамическое изменение DOM-дерева (AJAX).</p></li><li><p><a href="#events">События</a> &mdash; событийная модель <em>i-bem.js</em>: DOM-события,BEM-события, делегирование событий.</p></li><li><p><a href="#states">Состояния блока</a> &mdash; модификаторы, триггеры на сменусостояний (установку модификаторов), инициализация экземпляровблоков.</p></li><li><p><a href="#ibc">Взаимодействие блоков</a> &mdash; API для обращения из блока к другим блокам.</p></li><li><p><a href="#docs">Что дальше?</a> &mdash; ссылки на документацию и дополнительные материалы.</p></li></ul><p><a name="intro"></a></p><h1 id="общие-сведения">Общие сведения</h1><p><a name="intro-bem"></a></p><h2 id="бэм-методология-и-javascript">БЭМ-методология и JavaScript</h2><p>С точки зрения БЭМ-методологии веб-интерфейс строится из независимых<strong>блоков</strong> (внутри которых могут быть выделены <strong>элементы</strong>). И блоки,и элементы могут иметь состояния, описываемые <strong>модификаторами</strong>.</p><p>Работа веб-интерфейса обеспечивается несколькими <strong>технологиями</strong>(HTML, CSS, JS...). При использовании БЭМ-методологии вся реализациявеб-интерфейса разбита на компоненты по блокам. Описание блока в этойсхеме складывается из нескольких файлов &mdash; по одному на каждуютехнологию:</p><ul><li><code>my-block.css</code> &mdash; описывает внешний вид блока;</li><li><code>my-block.bemhtml</code> &mdash; шаблоны для генерации HTML-представления блока;</li><li><code>my-block.js</code> &mdash; описывает <strong>динамическое поведение</strong> блока в браузере.</li></ul><p>Фреймворк <em>i-bem.js</em> позволяет разложить клиентский JavaScript на компоненты в терминах БЭМ:</p><ul><li><strong>Блок</strong> &mdash; JS-компонент, описывающий логику работы однотипныхэлементов интерфейса. Например, все кнопки могут быть реализованы ввиде блока <code>button</code>. Тогда, в соответствии с БЭМ-методологией,<code>button.css</code> определяет внешний вид всех кнопок, а <code>button.js</code> &mdash;логику их работы.</li><li>На каждой странице может размещаться более одного <strong>экземпляраблока</strong> (например, кнопки). Каждому экземпляру блока соответствуетJS-объект, динамически создаваемый в памяти браузера и хранящийсостояние данного экземпляра. JS-объект хранит ссылку на DOM-узел,к которому привязан данный экземпляр блока.</li><li><strong>Элементы</strong> &mdash; DOM-узлы, вложенные в DOM-узел блока и имеющие атрибут<code>class</code>, указывающий на их роль в БЭМ-предметной области (имя блокаи элемента). Элементы блока доступны через <a href="#elem-api">JS-API</a>экземпляра блока.</li><li><strong>Модификаторы</strong> &mdash; хранят информацию о состоянии блока и егоэлементов. Состояние модификаторов записывается в атрибуте <code>class</code>на DOM-узлах блока и элементов. Управление модификаторамипроизводится через <a href="#mods-api">JS-API</a> экземпляра блока.</li></ul><p><a name="intro-use"></a></p><h2 id="как-использовать-i-bem-js">Как использовать i-bem.js</h2><p>Фреймворк <em>i-bem.js</em> входит в состав библиотеки <a href="http://github.com/bem/bem-core/">bem-core</a>.</p><p>Реализация <em>i-bem.js</em> состоит из двух модулей:</p><ul><li>Модуль <a href="https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/i-bem.vanilla.js"><code>i-bem</code></a>.<br>Базовая реализация JS-блока i-bem, от которой наследуются все блоки в<em>i-bem.js</em>. Блок <code>i-bem</code> написан с расчетом на использование в любомJS-окружении, как на клиенте, так и на сервере (например, вNode.js).</li><li>Модуль <a href="https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/__dom/i-bem__dom.js"><code>i-bem__dom</code></a>.<br> Базовая реализация блока, привязанногок DOM-узлу. Рассчитан на использование на клиенте, опирается на работубраузеров с DOM. Зависит от <code>jQuery</code>.</li></ul><p>Зависимости:</p><ul><li>jQuery (только для модуля <code>i-bem__dom</code>). При использовании bem-core отдельная установка jQuery не требуется.</li><li>Модульная система <a href="https://github.com/ymaps/modules">ymaps/modules</a>. При использовании<a href="http://ru.bem.info/tools/bem/">bem-tools</a> с технологией <code>.browser.js</code> (и производных от нее)эта зависимость удовлетворяется автоматически.</li></ul><p>Можно использовать <em>i-bem.js</em> как часть полного стекаБЭМ-инструментов. В этом случае свой проект удобно создавать на основешаблонного репозитория<a href="http://github.com/bem/project-stub/">project-stub</a>, в которомнастроена автоматическая установка зависимых библиотек.</p><p>Если не планируется использование других технологий БЭМ-платформы,достаточно скопировать код библиотеки bem-core в существующий проект.</p><p><a name="intro-build"></a></p><h2 id="сборка">Сборка</h2><p>Разработка в рамках БЭМ-методологии ведется модульно &mdash; каждый блокпрограммируется отдельно. Финальный исходный код веб-страницформируется из кода отдельных блоков с помощью процедур <strong>сборки</strong>.</p><p>В файловой системе блок удобно представлять в виде каталога, а реализацию блокав каждой из технологий &mdash; в виде отдельного файла:</p><pre><code class="lang-html hljs r">    desktop.blocks/        my-block/            my-block.css            my-block.js            my-block.bemhtml            <span class="hljs-keyword">...</span>    desktop.blocks/        other-block/            other-block.css            other-block.js            other-block.bemhtml            <span class="hljs-keyword">...</span></code></pre><p>Для каждой веб-страницы код использованных на ней блоков может быть собран в единые файлы:</p><pre><code class="lang-html hljs r">    desktop.bundles/        index/            index.html            index.css            index.js            <span class="hljs-keyword">...</span></code></pre><p>Для сборки кода результирующих веб-страниц из отдельныхописаний блоков существует два инструмента:</p><ul><li><a href="http://github.com/bem/bem-tools/">bem-tools</a>;</li><li><a href="https://github.com/enb-make/enb">enb</a> совместно с <a href="https://github.com/enb-make/enb-modules">enb-modules</a>.</li></ul><p><a name="intro-name"></a></p><h2 id="почему-i-bem-js-так-называется">Почему i-bem.js так называется</h2><p>В соответствии с БЭМ-методологией, базовая JS-библиотека БЭМ-платформы изначально разрабатываласькак особый служебный блок. Такой подход позволяет работать с базовыми библиотеками так же, каки с обычными блоками. В частности, структурировать код в терминах элементов и модификаторов игибко настраивать поведение библиотеки на разных уровнях переопределения.</p><p>Служебным блокам в БЭМ было принято давать имена с префиксом <code>i-</code>. Таким образом, имя <code>*i-bem.js*</code>читается как «реализация блока <code>i-bem</code> в технологии <code>js</code>».</p><p><a name="html"></a></p><h1 id="привязка-js-блоков-к-html">Привязка JS-блоков к HTML</h1><p>JavaScript-компоненты в <em>i-bem.js</em> служат для «оживления» HTML-элементовстраницы. Типовая задача JS-блока &mdash; привязать обработку определенных событий куказанному HTML-фрагменту.</p><p>При разработке веб-интерфейса в <em>i-bem.js</em> первичным «каркасом»является HTML-дерево документа. В HTML-дереве размечаются точки, ккоторым привязаны интерактивные элементы интерфейса &mdash; JS-блоки.Точка привязки JS-блока &mdash; HTML-элемент, в атрибуте <code>class</code> которогоуказано имя блока, а в атрибуте <code>data-bem</code> &mdash; <a href="#html-syntax">параметры блока</a>.</p><p>При загрузке страницы в браузере выполняется<a href="#init">инициализация блоков</a>. В процессе инициализации создаютсяэкземпляры блоков &mdash; JS-объекты для всех блоков, упомянутых вHTML-элементах на странице. JS-объект, привязанный к HTML-элементу,обрабатывает происходящие на нем <a href="#dom-events">DOM-события</a> и хранитсостояние данного экземпляра блока.</p><p><em>i-bem.js</em> дает возможность реализовать JS-компонент, не привязанный кHTML, &mdash; <a href="#i-blocks">блок без DOM-представления</a>. Такой блок предоставляет API,аналогичное обычным JS-блокам.</p><p>Описанный подход привязки JavaScript-компонент к HTML имеет следующие преимущества:</p><ul><li>естественная деградация интерфейса на клиентах с отключенным JavaScript;</li><li><em>прогрессивный рендеринг</em> &mdash; возможность начать отрисовку элементовинтерфейса до окончания загрузки всех данных страницы (например,изображений).</li></ul><p><a name="html-syntax"></a></p><h2 id="синтаксис-привязки-блоков">Синтаксис привязки блоков</h2><p>Чтобы привязать блок к HTML-элементу (например, <code>&lt;div&gt;...&lt;/div&gt;</code>), необходимо:</p><ul><li><strong>Отметить блок в HTML-дереве</strong>.<br>Включить имя блока в список классов HTML-элемента (атрибут <code>class</code>).</li></ul><pre><code class="lang-html hljs r">&lt;div class=<span class="hljs-string">"my-block"</span>&gt;<span class="hljs-keyword">...</span>&lt;/div&gt;</code></pre><ul><li><strong>Инициализировать экземпляр блока</strong>.<br>Включить класс <code>i-bem</code> в список классов HTML-элемента. Наличие этого класса позволит фреймворку инициализировать блок.</li></ul><pre><code class="lang-html hljs r">&lt;div class=<span class="hljs-string">"my-block i-bem"</span>&gt;<span class="hljs-keyword">...</span>&lt;/div&gt;</code></pre><ul><li><strong>Передать параметры экземпляру блока</strong>.<br> Поместить параметрыблока в атрибут <code>data-bem</code>. Параметры блока записываются в форматеJSON и представляют собой хэш вида: <strong>имя блока&mdash;хэш параметров</strong>. Параметрыпередаются экземпляру блока в момент инициализации(<a href="#data-bem">подробнее...</a>).</li></ul><pre><code class="lang-html hljs r">&lt;div class=<span class="hljs-string">"my-block i-bem"</span> data-bem=<span class="hljs-string">&quot;{ "my-block": { "name": "ya" } }&quot;</span>&gt;<span class="hljs-keyword">...</span>&lt;/div&gt;</code></pre><p>Одному HTML-элементу не обязательно должен соответствовать одинэкземпляр блока. Возможны следующие типы связи между блоками иHTML-элементами:</p><ul><li><a href="#html-simple">Один HTML-элемент &mdash; один JS-блок</a>;</li><li><a href="#html-mixes">Один HTML-элемент &mdash; несколько JS-блоков</a>;</li><li><a href="#distrib-block">Один JS-блок на нескольких HTML-элементах</a>;</li><li><a href="#i-blocks">Блоки без DOM-представления</a>.</li></ul><p><a name="html-simple"></a></p><h3 id="один-html-элемент-&mdash;-один-js-блок">Один HTML-элемент &mdash; один JS-блок</h3><p>Самый простой и распространенный способ привязки блоков к HTML.</p><p><strong>Пример</strong>: HTML-элемент <code>div</code>, на котором размещен блок <code>my-block</code>, параметры блока &mdash; пустой список <code>{}</code>.</p><pre><code class="lang-html hljs r">&lt;div class=<span class="hljs-string">"my-block i-bem"</span> data-bem=<span class="hljs-string">&quot;{ "my-block": {} }&quot;</span>&gt;    <span class="hljs-keyword">...</span>&lt;/div&gt;</code></pre><p><a name="html-mixes"></a></p><h3 id="один-html-элемент-&mdash;-несколько-js-блоков">Один HTML-элемент &mdash; несколько JS-блоков</h3><p>Техника размещения нескольких блоков на одном HTML-элементе в БЭМ-методологии называется <strong>микс</strong>.</p><p><strong>Пример</strong>: HTML-элемент <code>div</code>, на котором размещены блок <code>user</code> спараметром <code>name</code>: <code>pushkin</code> и блок <code>avatar</code> с параметром <code>img</code>: <code>http://...</code>.</p><pre><code class="lang-html hljs r">&lt;div class=<span class="hljs-string">"user avatar i-bem"</span>    data-bem=<span class="hljs-string">&quot;{        "user": { "name": "pushkin" },        "avatar": { "img": "http://..." }     }&quot;</span>&gt;     <span class="hljs-keyword">...</span>&lt;/div&gt;</code></pre><p><a name="distrib-block"></a></p><h3 id="один-js-блок-на-нескольких-html-элементах">Один JS-блок на нескольких HTML-элементах</h3><p>Такой дизайн позволяет прозрачно реализовывать блоки, состоящие изнескольких компонентов, состояние которых должно бытьсогласовано. Например, виджет «вкладки», где клик по заголовку вкладки(один HTML-элемент), меняет содержимое вкладки (другойHTML-элемент). Другой пример &mdash; маркер, обозначающий точку на карте(первый элемент) и связанное с ним описание точки в списке рядом скартой (второй элемент).</p><p>Чтобы привязать экземпляр блока к нескольким HTML-элементам, нужно в параметрахблока на всех связанных с ним HTML-элементах указать одинаковое значение <code>id</code>. Вкачестве значения <code>id</code> может выступать произвольная строка.</p><p><strong>Пример</strong>: Экземпляр блока <code>notebook</code> привязан к HTML-элементам <code>div</code> и <code>span</code>, впараметрах блока указан общий <code>id</code> &mdash; <code>maintab</code>.</p><pre><code class="lang-html hljs r">&lt;div class=<span class="hljs-string">"notebook i-bem"</span> data-bem=<span class="hljs-string">&quot;{ "notebook": { "id": "maintab" }}&quot;</span>&gt;&lt;/div&gt;<span class="hljs-keyword">...</span>&lt;span class=<span class="hljs-string">"notebook i-bem"</span> data-bem=<span class="hljs-string">&quot;{ "notebook": { "id": "maintab" }}&quot;</span>&gt;&lt;/span&gt;</code></pre><p>В результате при инциализации блоков создается один JS-объект, поле <a href="#domElem"><code>{jQuery} domElem</code></a> которого содержит ссылки на оба DOM-узла.</p><p>Идентификатор <code>id</code> используется <em>только в момент инициализации</em>экземпляра блока. Значение <code>id</code> должно быть уникальным в пределахэкземпляров одного блока в рамках одной<a href="#init-wave">волны инициализации</a>.</p><p><a name="i-blocks"></a></p><h3 id="блоки-без-dom-представления">Блоки без DOM-представления</h3><p>Инфраструктурный код, решающий общие задачи интерфейса: связь сбэкэндом, общие вычисления и т.п. &mdash; при работе с <em>i-bem.js</em> можнооформлять в виде блока, как и весь прочий JS-код. Чтобы не привязыватьтакие блоки к HTML-дереву икусственно, <em>i-bem.js</em> предоставляетвозможность создавать блоки без DOM-представления.</p><p>Блоки без DOM-представления:</p><ul><li>Не указываются в HTML-коде страницы.</li><li>Декларируются как <a href="#bem-decl">доопределение модуля <code>i-bem</code></a>, а не<code>i-bem__dom</code>, как блоки с DOM-представлением.</li><li>Должны быть <a href="#init-bem">инициализированы явно</a>.</li></ul><h3 id="блоки-миксы">Блоки-миксы</h3><p>Часто в проекте одна и та же функциональность может быть востребована в нескольких блоках. Например, разные блоки могут обращаться за данными к бэкенду, используя AJAX, или совершать однотипные операции с DOM-деревом и т.д. Чтобы избежать ненужных повторов в коде, общую функциональность можно инкапсулировать в виде модулей, а затем примешивать к блокам. </p><p>В <em>i-bem.js</em> для добавления востребованной функциональности к блокам, используется специальный тип блоков &ndash; <strong>блоки-миксы</strong>. Главная особенность блоков-миксов состоит в том, что они не участвуют в цепочке наследования. Это позволяет примешивать, реализованную в них функциональность к блокам, без риска нарушения их связей с родительскими блоками (вызов базовых методов (<code>this.__base</code>) и т.д.).</p><p><a name="data-bem"></a></p><h2 id="синтаксис-передачи-параметров">Синтаксис передачи параметров</h2><p>Параметры блока хранятся в атрибуте <code>data-bem</code> HTML-элемента ипередаются блоку в момент инициализации.  Параметры позволяютмодифицировать поведение экземпляра блока, привязанного к данномуHTML-элементу.</p><p>В значении атрибута <code>data-bem</code> указываются параметры <em>всех JS-блоков, размещенных на данном узле</em>.Параметры передаются в формате JSON в виде хэша:</p><ul><li>ключ &mdash; <code>{String}</code> имя блока;</li><li>значение &mdash; <code>{Object}</code> параметры данного блока. Если данному экземпляру блока не требуютсяпараметры, указывается пустой хэш <code>{}</code>.</li></ul><p>Значение атрибута <code>data-bem</code> должно содержать валидный JSON.</p><p>Такой формат параметров продиктован следующими соображениями:</p><ul><li>Указание имени блока в параметрах позволяет избежать необходимостипарсить значение атрибута <code>class</code>, что упрощает и ускоряетинициализацию блоков.</li><li>Это же решение позволяет размещать несколько блоков на одномHTML-элементе без необходимости множить атрибуты элемента.</li></ul><p><a name="decl"></a></p><h1 id="декларация-блока">Декларация блока</h1><p>JS-реализация блока описывает поведение определенного класса элементов веб-интерфейса. В конкретныхинтерфейсах каждый блок может быть представлен несколькими экземплярами. Каждый экземпляр блока реализуетфункциональность всего класса и имеет собственное состояние, независимое от остальных.</p><p>В терминах парадигмы объектно-ориентированного программирования:</p><ul><li>блок &mdash; класс;</li><li>экземпляр блока &mdash; экземпляр класса.</li></ul><p>В соответствии с ООП, вся функциональность блока реализуется модульно в <em>методах</em> класса (= блока).Методы блока подразделяются на:</p><ul><li>методы экземпляра блока;</li><li>статические методы.</li></ul><p>Код блока в <em>i-bem.js</em> принято называть <strong>декларацией</strong>, чтобы подчеркнуть принятый в БЭМ декларативныйстиль программирования. Поведение блока программируется вдекларативном стиле в виде утверждений: <em>набор условий &mdash; реакция блока</em>.</p><h2 id="синтаксис-декларации">Синтаксис декларации</h2><p>Чтобы декларировать новый JS-блок <strong>с DOM-представлением</strong>(привязанный к HTML-элементу), необходимо доопределить <a href="https://github.com/ymaps/modules">ymaps</a>-модуль <code>i-bem__dom</code>.</p><p>Блоки декларируются с помощью метода <code>decl</code>, принимающим трипараметра:</p><ol><li>Имя блока <code>{String}</code> или <a href="#decl-selector">описание блока</a> <code>{Object}</code>.</li><li>Методы экземпляра блока &mdash; <code>{Object}</code>.</li><li>Статические методы &mdash; <code>{Object}</code>.</li></ol><pre><code class="lang-js hljs lasso">modules<span class="hljs-built_in">.</span><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&quot;i-bem__dom&quot;</span>, function(<span class="hljs-keyword">provide</span>, DOM) {DOM<span class="hljs-built_in">.</span>decl(<span class="hljs-comment">/* имя или описание блока */</span>,    {        <span class="hljs-comment">/* методы экземпляра */</span>    },    {        <span class="hljs-comment">/* статические методы */</span>    });<span class="hljs-keyword">provide</span>(DOM);});</code></pre><hr><p><strong>NB:</strong> С точки зрения модульной системы <a href="https://github.com/ymaps/modules">ymaps</a>, декларации разных  блоков представляеют собой переопределение одного и того же модуля  <code>i-bem__dom</code>. Однако с точки зрения <em>i-bem.js</em> таким образом создаются  <em>разные объекты</em> для построения экземпляров блоков.</p><hr><p><a name="bem-decl"></a></p><p>Блоки, не имеющие DOM-представления, декларируются как доопределение <a href="https://github.com/ymaps/modules">ymaps</a>-модуля <code>i-bem</code>.Для декларации используется метод <code>decl</code>, принимающий те же параметры,что и метод <code>decl</code> модуля <code>i-bem__dom</code>:</p><pre><code class="lang-js hljs lasso">modules<span class="hljs-built_in">.</span><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&quot;i-bem&quot;</span>, function(<span class="hljs-keyword">provide</span>, BEM) {BEM<span class="hljs-built_in">.</span>decl(<span class="hljs-comment">/* имя или описание блока */</span>,    {        <span class="hljs-comment">/* методы экземпляра */</span>    },    {        <span class="hljs-comment">/* статические методы */</span>    });<span class="hljs-keyword">provide</span>(BEM);});</code></pre><hr><p><strong>NB:</strong> Оформлять инфраструктурный код в виде блока без  DOM-представления удобно, если в нем планируется использовать API  БЭМ-блоков (состояния, выражаемые модификаторами, BEM-события и  т. п.). Если использовать БЭМ-предметную область не планируется,  инфраструктурный код можно оформлять в виде <a href="https://github.com/ymaps/modules">ymaps</a>-модуля.</p><p><strong>Пример</strong>:</p><pre><code class="lang-js hljs r">modules.define(<span class="hljs-string">&quot;router&quot;</span>, <span class="hljs-keyword">function</span>(provide) {provide({    route : <span class="hljs-keyword">function</span>() { /* <span class="hljs-keyword">...</span> */ }});});</code></pre><hr><p><a name="decl-selector"></a></p><h2 id="описание-блока-в-декларации">Описание блока в декларации</h2><p>Первый параметр метода <code>decl</code> представляет собой описание блока, вкотором будут применяться объявленные в декларации методы. Описаниеобязательно содержит имя блока и может дополнительно содержать:</p><ul><li>ограничение сферы действия декларации определенной модификациейблока;</li><li>список родительских блоков, методы которых должен наследовать данныйблок.</li></ul><p>Описание может быть задано в одной из двух форм:</p><ol><li>Имя блока &mdash; строка.<br>Объявленные методы будут применяться во всех экземплярах блока независимо от их состояний (модификаторов).</li></ol><p><strong>Пример</strong>: декларация методов для блока <code>button</code>.</p><pre><code class="lang-js hljs coffeescript">DOM.decl(<span class="hljs-string">&quot;button&quot;</span>,    { <span class="hljs-regexp">/* методы экземпляра */</span> },    { <span class="hljs-regexp">/* статические методы */</span> });</code></pre><ol><li>Описание блока &mdash; хэш.<br> Содержит имя (и значение)модификатора. Объявленные методы будут применяться только к темэкземплярам блока, у которых присутствует данный модификатор (суказанным значением).</li></ol><p><strong>Пример</strong>: декларация методов для блока <code>button</code> с модификатором<code>type</code> в значении <code>link</code> (описывает поведение псевдокнопок):</p><pre><code class="lang-js hljs css"><span class="hljs-tag">DOM</span><span class="hljs-class">.decl</span>(<span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">block</span>:<span class="hljs-value"> <span class="hljs-string">&quot;button&quot;</span>, modName: <span class="hljs-string">&quot;type&quot;</span>, modVal: <span class="hljs-string">&quot;link&quot;</span> </span></span></span>},    <span class="hljs-rules">{ <span class="hljs-comment">/* методы экземпляра */</span> <span class="hljs-rule">}</span></span>,    <span class="hljs-rules">{ <span class="hljs-comment">/* статические методы */</span> <span class="hljs-rule">}</span></span>);</code></pre><hr><p><strong>NB:</strong> Если в декларации для блока с указанием конкретных  модификаторов описаны статические методы, они будут применяться ко всем  экземплярам данного блока <em>вне зависимости от значений  модификаторов</em>. Модификаторы являются свойствами экземпляров блоков,  а статические методы принадлежат классу блока и поэтому не могут  учитывать ограничения по модификатору.</p><hr><h3 id="описание-блока-микса-в-декларации">Описание блока-микса в декларации</h3><p>Чтобы подмешать к блоку один или несколько блоков-миксов, нужно в описании блока присвоить значение опциональному полю <code>baseMix</code>.  Значением должен выступать массив имен, примешиваемых блоков-миксов:</p><pre><code class="lang-js hljs css"><span class="hljs-tag">DOM</span><span class="hljs-class">.decl</span>(<span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">block</span>:<span class="hljs-value"> <span class="hljs-string">&quot;myblock&quot;</span>, baseMix: [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>]</span></span></span>},    <span class="hljs-rules">{ <span class="hljs-comment">/* методы экземпляра */</span> <span class="hljs-rule">}</span></span>,    <span class="hljs-rules">{ <span class="hljs-comment">/* статические методы */</span> <span class="hljs-rule">}</span></span>);</code></pre><h4 id="декларация-блока-микса">Декларация блока-микса</h4><p>В качестве блоков-миксов можно использовать только блоки, задекларированные с помощью <code>declMix</code>. Этот метод принимает декларацию блока в формате, аналогичном методу <code>decl</code>:</p><pre><code class="lang-js hljs coffeescript">BEM.declMix(<span class="hljs-string">&quot;mymix&quot;</span>,    { <span class="hljs-regexp">/* свойства и методы экземпляра */</span> },    { <span class="hljs-regexp">/* статические свойства и методы */</span> });</code></pre><hr><p><strong>NB:</strong> Первым аргументом в декларации блока-микса всегда выступает строка &ndash; имя блока. Это связано с тем, что для блоков-миксов не предполагаются возможности использования модификаторов или примешивания блоков. </p><hr><h2 id="#">#</h2><h2 id="контекст">Контекст</h2><p><strong>Методы экземпляра блока</strong> исполняются в контексте JS-объектаэкземпляра блока. Соответственно, ключевое слово <code>this</code> в методахэкземпляра блока ссылается на JS-объект <strong>экземпляра блока</strong>.</p><p><strong>Статические методы</strong> исполняются в контексте JS-объекта,  соответствующего классу блока. Соответственно, ключевое слово <code>this</code>  в статических методах блока ссылается на <strong>класс блока</strong>, а не на  экземпляр.</p><p>Контекст содержит зарезервированные поля:</p><ul><li><p><code>this.__self</code>: Ссылается на статические методы класса, к которомупринадлжит экземпляр. Определен в методах экземпляра блока. Длястатических методов не имеет смысла и не определен.</p><p> <strong>Пример</strong>: Вызов статического метода <code>staticMethod</code> в методе <code>onEvent</code> экземпляра блока <code>my-block</code>.</p></li></ul><pre><code class="lang-js hljs r">DOM.decl(<span class="hljs-string">&quot;my-block&quot;</span>, {    onEvent: <span class="hljs-keyword">function</span>() {        this.__self.staticMethod(); // вызов статического метода        this.doMore();    },    {        staticMethod: <span class="hljs-keyword">function</span>() { /* <span class="hljs-keyword">...</span> */ }; // определение статического метода    }});</code></pre><ul><li><p><code>this.__base</code>: Ссылается на реализацию метода в базовом классе, от которого наследуется данный. Позволяет выполнить super call. Определен в методах экземпляра блока и в статических методах блока.</p><p> <strong>Пример</strong>: вызов (и модификация) метода <code>_onClick</code> родительского класса (базовой реализации метода в классе <code>button</code>).</p></li></ul><pre><code class="lang-js hljs actionscript">DOM.decl({ block: <span class="hljs-string">&quot;my-button&quot;</span>, baseBlock: <span class="hljs-string">&quot;button&quot;</span> }, {    _onClick: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>        <span class="hljs-keyword">this</span>.__base();        <span class="hljs-keyword">this</span>.doMore();    });</code></pre><hr><p><strong>NB:</strong> Так как блоки-миксы не участвуют в цепочке наследования, внутри них нельзя использовать <code>__base</code>, для обращения к родительскому блоку. </p><hr><p><strong>NB:</strong> При разработке блоков с использованием <em>i-bem.js</em> внутренним  методам блока, не предназначенным для использования извне, принято  давать имена, начинающиеся с символа подчеркивания. Например,  <code>_onClick</code>.</p><hr><p><a name="dom"></a></p><h1 id="работа-с-dom-деревом">Работа с DOM-деревом</h1><p><a name="domElem"></a></p><h2 id="dom-узел-экземпляра-блока">DOM-узел экземпляра блока</h2><p>Все экземпляры блоков, привязанные к DOM-дереву, содержат в поле<code>{jQuery} this.domElem</code> jQuery-объект, ссылающийся на один илинесколько DOM-узлов, с которыми связан данный экземпляр блока.</p><p><a name="elem-api"></a></p><h2 id="элементы">Элементы</h2><p>БЭМ-элементы блоков представлены в <em>i-bem.js</em> как DOM-узлы, вложенныев DOM-узел экземпляра блока. Для обращения к DOM-узлам элементов иработы с их модификаторами, следует использовать API, предоставляемыйэкземпляром блока.</p><p>Экземпляр блока предоставляет два метода для обращения к элементам данного    экземпляра:</p><ul><li>Кеширующий доступ: <code>elem(elems, [modName], [modVal])</code>. Элемент,полученный таким образом, не требуется сохранять в переменную.</li></ul><pre><code class="lang-js hljs r">DOM.decl(<span class="hljs-string">&quot;b-link&quot;</span>, {    setInnerText: <span class="hljs-keyword">function</span>() {        this.elem(<span class="hljs-string">&quot;inner&quot;</span>).text(<span class="hljs-string">&quot;Текст ссылки&quot;</span>);        /* <span class="hljs-keyword">...</span> */        this.elem(<span class="hljs-string">&quot;inner&quot;</span>).text(<span class="hljs-string">&quot;Другой текст&quot;</span>);    });</code></pre><ul><li>Некеширующий доступ: <code>findElem(elems, [modName], [modVal])</code>.</li></ul><pre><code class="lang-js hljs r">DOM.decl(<span class="hljs-string">&quot;b-link&quot;</span>, {    setInnerText: <span class="hljs-keyword">function</span>() {        var inner = this.findElem(<span class="hljs-string">&quot;inner&quot;</span>);        inner.text(<span class="hljs-string">&quot;Текст ссылки&quot;</span>);        /* <span class="hljs-keyword">...</span> */        inner.text(<span class="hljs-string">&quot;Другой текст&quot;</span>);    }});</code></pre><p>При <a href="#dynamic">динамическом добавлении и удалении элементов блока</a> можетвозникнуть необходимость сброса кеша элементов. Для этого предназначенметод <code>dropElemCache(&quot;elements&quot;)</code>. В качестве параметра указываетсяразделенный пробелами список имен элементов, кеш для которых нужносбросить:</p><pre><code class="lang-js hljs actionscript">DOM.decl(<span class="hljs-string">&quot;attach&quot;</span>, {    clear: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>        DOM.destruct(<span class="hljs-keyword">this</span>.elem(<span class="hljs-string">&quot;control&quot;</span>));        DOM.destruct(<span class="hljs-keyword">this</span>.elem(<span class="hljs-string">&quot;file&quot;</span>));        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.dropElemCache(<span class="hljs-string">&quot;control file&quot;</span>);    }});</code></pre><p>Полное описание API для работы с элементами содержится висходном коде модуля <a href="https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/__dom/i-bem__dom.js"><code>i-bem__dom</code></a>.</p><p><a name="dynamic"></a></p><h2 id="динамическое-обновление-блоков-и-элементов-в-dom-дереве">Динамическое обновление блоков и элементов в DOM-дереве</h2><p>В современных интерфейсах зачастую необходимо создавать новыефрагменты DOM-дерева и заменять старые в процессе работы (AJAX). В<em>i-bem.js</em> предусмотрены следующие функции для добавления и заменыфрагментов DOM-дерева.</p><ul><li><p>Добавить DOM-фрагмент:</p><ul><li><code>append</code> &mdash;  в конец указанного контекста;</li><li><code>prepend</code> &mdash; в начало указанного контекста;</li><li><code>before</code> &mdash; перед указанным контекстом;</li><li><code>after</code> &mdash; после указанного контекста;</li></ul></li><li><p>Заместить DOM-фрагмент:</p><ul><li><code>update</code> &mdash;  внутри указанного контекста;</li><li><code>replace</code> &mdash; заменить указанный контекст новым DOM-фрагментом.</li></ul></li></ul><p>Все функции автоматически выполняют <a href="#init-ajax">инициализацию блоков наобновленном фрагменте DOM-дерева</a>.</p><p>Чтобы упростить создание БЭМ-сущностей на обновляемых фрагментахDOM-дерева, можно использовать шаблонизатор<a href="http://ru.bem.info/articles/bemhtml-reference/">BEMHTML</a>, подключивего в качестве <a href="https://github.com/ymaps/modules">ymaps</a>-модуля.  БЭМ-сущности описываются в формате<a href="http://ru.bem.info/articles/bemhtml-reference#bemjson">BEMJSON</a>непосредственно в коде блока.  Функция <code>BEMHTML.apply</code> генерируетHTML-элементы по BEMJSON-описанию в соответствии с правиламиименования БЭМ.</p><p><strong>Пример</strong>: В методе <code>_updateFileElem</code> блока <code>attach</code> выполняется  удаление элемента <code>file</code>, если он существовал, и генерация нового  элемента с помощью функции <code>BEMHTML.apply</code>:</p><pre><code class="lang-js hljs javascript">modules.define(    <span class="hljs-string">&quot;i-bem__dom&quot;</span>,    [<span class="hljs-string">&quot;BEMHTML&quot;</span>, <span class="hljs-string">&quot;strings__escape&quot;</span>],    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, BEMHTML, escape, DOM)</span> {</span>DOM.decl(<span class="hljs-string">&quot;attach&quot;</span>, {    _updateFileElem : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>        <span class="hljs-keyword">var</span> fileName = extractFileNameFromPath(<span class="hljs-keyword">this</span>.getVal());        <span class="hljs-keyword">this</span>.elem(<span class="hljs-string">&quot;file&quot;</span>).length &amp;&amp; DOM.destruct(<span class="hljs-keyword">this</span>.elem(<span class="hljs-string">&quot;file&quot;</span>));        DOM.append(            <span class="hljs-keyword">this</span>.domElem,            BEMHTML.apply({                block : <span class="hljs-string">&quot;attach&quot;</span>,                elem : <span class="hljs-string">&quot;file&quot;</span>,                content : [                    {                        elem : <span class="hljs-string">&quot;icon&quot;</span>,                        mods : { file : extractExtensionFromFileName(fileName) }                    },                    { elem : <span class="hljs-string">&quot;text&quot;</span>, content : <span class="hljs-built_in">escape</span>.html(fileName) },                    { elem : <span class="hljs-string">&quot;clear&quot;</span> }                ]            }));        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.dropElemCache(<span class="hljs-string">&quot;file&quot;</span>);    }});provide(DOM);});</code></pre><p><a name="events"></a></p><h1 id="события">События</h1><p>В <em>i-bem.js</em> поддерживается два вида событий:</p><p><a name="dom-events"></a></p><ul><li><strong>DOM-событие</strong> &mdash; JavaScript-событие на DOM-узле, связанном сблоком. Отражает взаимодействие пользователя с интерфейсом (клик,наведение мыши, ввод текста и т.п.). DOM-событие обычно обрабатываеттот экземпляр блока, на DOM-узле которого оно возникло.</li><li><strong>BEM-событие</strong> &mdash; собственное событие, генерируемоеблоком. Позволяет организовать API для<a href="#ibc">взаимодействия с блоком</a>. BEM-события обычно обрабатываетэкземпляр блока, отслеживающий состояние других блоков, на которыхгенерируются события.</li></ul><p>Планируя архитектуру интерфейса, нужно учитывать, что DOM-событияследует использовать только во <em>внутренних</em> процедурах блока. Длявзаимодействия блока с <em>внешней</em> средой (другими блоками),предназначены BEM-события.</p><hr><p><strong>NB:</strong> Работа с DOM-событиями полностью реализована средствами  фреймворка jQuery.</p><hr><p><a name="delegated-events"></a></p><h2 id="делегирование-событий">Делегирование событий</h2><p>Обработка BEM- и DOM-событий может быть <strong>делегирована</strong> контейнеру(всему документу или конкретному DOM-узлу). В этом случае контейнерслужит точкой обработки событий, возникающих на любом издочерних узлов контейнера, даже если в момент подписки на событиянекоторые из дочерних узлов еще не существовали.</p><p>Например, блок меню может содержать вложенные блоки (или элементы &mdash; взависимости от конкретной реализации блока) &mdash; пункты меню. Обработкукликов на пунктах меню имеет смысл делегировать самому блокуменю. Это, во-первых, позволяет сэкономить затраты ресурсов наподписку на события (дешевле подписаться на одно событие контейнера,чем на много событий элементов). Во-вторых, это дает возможность болеегибко изменять состав меню: добавлять и удалять пункты, не выполняяпри этом подписку на события добавленных пунктов меню и отменуподписки на события удаленных.</p><ul><li><p><a href="#dom-events-delegated"><strong>Делегирование DOM-событий</strong></a> можноиспользовать для обработки DOM-событий, происходящих на DOM-узлеэкземпляра блока или на DOM-узлах его элементов. ДелегированиеDOM-событий может выполняться либо для всех экземпляров блоковданного типа в пределах документа, либо только для экземпляровблоков внутри указанного контекста (фрагмента HTML-дерева).</p><p>  Контейнером, которому делегируется обработка DOM-событий, всегда  выступает <code>window.document</code>.</p></li></ul><ul><li><p><a href="#bem-events-delegated"><strong>Делегирование BEM-событий</strong></a> следуетиспользовать для обработки событий на <em>экземплярах блоков</em>,содержащихся внутри указанного DOM-узла.</p><p>  Контейнером, которому делегируется обработка BEM-событий, может  служить <strong>произвольный DOM-узел</strong>. По умолчанию в качестве  контейнера выступает весь документ (<code>window.document</code>). Часто блок  обрабатывает BEM-события вложенных блоков, тогда в качестве  контейнера следует указать DOM-узел блока-обработчика  <a href="#domElem"><code>this.domElem</code></a>.</p></li></ul><p>Полный список хелперов для подписки на делегированные событияможно найти в исходном коде модуля <a href="https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/__dom/i-bem__dom.js"><code>i-bem__dom</code></a>.</p><h2 id="dom-события">DOM-события</h2><p>Для подписки на DOM-события на узлах, связанных с блоком илиэлементом, используются метод экземпляра блока <code>bindTo([elem], event,handler)</code>.</p><p><strong>Пример</strong>: В момент <a href="#init">инициализации экземпляра блока</a><code>my-block</code> выполняется подписка на событие <code>click</code>, при наступлениикоторого блок выставляет себе <a href="#modifier">модификатор</a> <code>size</code> взначение <code>big</code>.</p><pre><code class="lang-js hljs javascript">DOM.decl(<span class="hljs-string">&quot;my-block&quot;</span>, {    onSetMod : {        <span class="hljs-string">&quot;js&quot;</span> : {            <span class="hljs-string">&quot;inited&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>                <span class="hljs-keyword">this</span>.bindTo(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> {</span>                    <span class="hljs-keyword">var</span> domElem = $(e.currentTarget); <span class="hljs-comment">// DOM-элемент, на котором слушается событие</span>                                                      <span class="hljs-comment">// в данном случае то же, что this.domElem</span>                    <span class="hljs-keyword">this</span>.setMod(<span class="hljs-string">&quot;size&quot;</span>, <span class="hljs-string">&quot;big&quot;</span>);                });            }        }    }});</code></pre><p><strong>Пример</strong>: При <a href="#init">инициализации экземпляра блока</a> <code>my-form</code> выполняется  подписка на событие <code>click</code> элемента <code>submit</code>, при наступлении  которого будет вызван метод экземпляра блока <code>_onSubmit</code>.</p><pre><code class="lang-js hljs javascript">DOM.decl(<span class="hljs-string">&quot;my-block&quot;</span>, {    onSetMod : {        <span class="hljs-string">&quot;js&quot;</span> : {            <span class="hljs-string">&quot;inited&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>                <span class="hljs-keyword">this</span>.bindTo(<span class="hljs-string">&quot;submit&quot;</span>, <span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> {</span>                    <span class="hljs-keyword">var</span> domElem = $(e.currentTarget); <span class="hljs-comment">// DOM-элемент, на котором слушается событие</span>                                                      <span class="hljs-comment">// в данном случае то же, что this.elem(&quot;submit&quot;)</span>                    <span class="hljs-keyword">this</span>._onSubmit();                });            }        }    },    _onSubmit : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> <span class="hljs-comment">/* ... */</span> }});</code></pre><hr><p><strong>NB:</strong> Функция-обработчик выполняется в контексте того экземпляра  блока, в котором возникло событие.</p><hr><p><strong>Удаление подписки</strong> на DOM-события выполняется автоматически приуничтожении экземпляра блока. Если необходимо удалить подписку вручнуюв процессе работы блока, следует использовать метод<code>unbindFrom([elem], event, handler)</code>.</p><p><a name="dom-events-delegated"></a></p><h3 id="делегирование-dom-событий">Делегирование DOM-событий</h3><p>Делегирование обработки DOM-событий выполняется с помощью метода<code>liveBindTo([elem], event, handler)</code>. В декларации блока точкой,зарезервированной для подписки на делегированные DOM-события, служитсвойство <code>live</code> в разделе статических методов блока.</p><p><strong>Пример</strong>: Все экземпляры блока <code>menu</code> подписываются на  делегированное DOM-событие <code>click</code> своих элементов <code>item</code>. Метод  <code>_onItemClick</code> экземпляра блока <code>menu</code> будет выполняться при клике  на любой пункт (элемент <code>item</code>) в этом меню. Не имеет значения,  существовал ли этот пункт в момент инициализации экземпляра блока.</p><pre><code class="lang-js hljs javascript">DOM.decl(<span class="hljs-string">&quot;menu&quot;</span>, {    _onItemClick : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> {</span>        <span class="hljs-keyword">var</span> clickedItem = $(e.currentTarget); <span class="hljs-comment">// элемент &quot;item&quot; блока &quot;menu&quot;, на котором слушается DOM-событие &quot;click&quot;</span>    }}, {    live : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>        <span class="hljs-keyword">this</span>.liveBindTo(<span class="hljs-string">&quot;item&quot;</span>, <span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>            <span class="hljs-keyword">this</span>._onItemClick();        });        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// если инициализация блока не может быть отложена</span>    }});</code></pre><p>По умолчанию при наличии в декларации блока свойства <code>live</code>инициализация экземпляров блока будет <em>отложена</em> до момента, когдаэкземпляр блока потребуется в работе(<a href="#init-live">ленивая инициализация</a>). Таким моментом может бытьDOM-событие на экземпляре блока, на которое выполнена делегированнаяподписка, или обращение к экземпляру блока <a href="#ibc">из другого блока</a>.Если инициализация блока не может быть отложена (требуется<a href="#init-auto">автоматическая инициализация</a>), следует вернуть <code>false</code> врезультате выполнения функции в значении свойства <code>live</code>.</p><hr><p><strong>NB:</strong> Функция-обработчик выполняется в контексте ближайшего блока  данного типа на пути распространения DOM-события (снизу вверх по  DOM-дереву).</p><hr><p><strong>Удаление подписки</strong> на делегированные DOM-события никогда не  выполняется автоматически. Если подписку необходимо удалить, следует  воспользоваться методом <code>liveUnbindFrom([elem], event, [handler])</code>.</p><h3 id="объект-dom-события">Объект DOM-события</h3><p>В качестве параметра функции-обработчику передается jQuery-объект,описывающий DOM-событие &mdash; <a href="http://api.jquery.com/category/events/event-object/"><code>{jQuery.Event}</code></a>.</p><p>Если DOM-событие было сгенерировано вручную, все параметры, переданныефункции <code>trigger</code> при создании события, будут переданыфункции-обработчику в том же порядке после объекта события.</p><p><a name="bem-events"></a></p><h2 id="bem-события">BEM-события</h2><p>В отличие от DOM-событий, BEM-события генерируются не наDOM-элементах, а на <strong>экземплярах блоков</strong>. Элементы блоков не могутгенерировать BEM-события.</p><p>Чтобы сгенерировать BEM-событие, используется метод экземпляра блока<code>emit(event)</code>.</p><p><strong>Пример</strong>: Взаимодействие пользователя с элементом управления блока  (DOM-событие) можно преобразовать в BEM-событие на блоке. В  приведенном ниже примере при клике пользователя по кнопке <code>submit</code>  (DOM-событие <code>click</code>) <strong>BEM-событие</strong> <code>click</code> генерируется только в  том случае, если у блока в этот момент не выставлен модификатор  <code>disabled</code>:</p><pre><code class="lang-js hljs actionscript">DOM.decl(<span class="hljs-string">&quot;submit&quot;</span>, {    onSetMod: {        <span class="hljs-string">&quot;js&quot;</span>: {            <span class="hljs-string">&quot;inited&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>                <span class="hljs-keyword">this</span>.bindTo(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">this</span>._onClick); <span class="hljs-comment">// подписка на DOM-событие "click"</span>            }        }    },    _onClick: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.hasMod(<span class="hljs-string">&quot;disabled&quot;</span>)) {            <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">&quot;click&quot;</span>); <span class="hljs-comment">// создание BEM-события "click"</span>        }    }});</code></pre><p>Для подписки на BEM-события экземпляров блоков используются методыэкземпляра блока <code>on(event, [data], handler, [handlerCtx])</code>.</p><p><strong>Пример</strong>: В момент инициализации HTML-формы (экземпляра блока <code>my-form</code>)выполняется поиск вложенной в форму кнопки <code>submit</code> и подписка наBEM-событие <code>click</code> этой кнопки. В результате при нажатии на кнопку(экземпляр блока <code>submit</code>) будет выполнен метод <code>_onSubmit</code> формы(экземпляр блока <code>my-form</code>).</p><pre><code class="lang-js hljs actionscript">DOM.decl(<span class="hljs-string">&quot;my-form&quot;</span>, {    onSetMod: {        <span class="hljs-string">&quot;js&quot;</span>: {            <span class="hljs-string">&quot;inited&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>                <span class="hljs-keyword">this</span>.findBlockInside(<span class="hljs-string">&quot;submit&quot;</span>).on(                    <span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-comment">// имя BEM-события</span>                    <span class="hljs-keyword">this</span>._onSubmit, <span class="hljs-comment">// метод экземпляра блока my-form</span>                    <span class="hljs-keyword">this</span>); <span class="hljs-comment">// контекст для выполнения _onSubmit &mdash; блок my-form</span>            }        }    },    _onSubmit: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> <span class="hljs-comment">/* ... */</span> }});</code></pre><hr><p><strong>NB:</strong> Если не указывать последний параметр метода <code>on</code> &mdash;  <code>[handlerCtx]</code>, контекстом для выполнения функции-обработчика будет  тот блок, в котором возникло BEM-событие. (В примере выше &mdash; это блок  <code>submit</code>.)</p><hr><p><strong>Удаление подписки</strong> на BEM-события выполняется автоматически приуничтожении экземпляра блока. Если требуется удалить подписку вручнуюв процессе работы блока, следует использовать метод экземпляра блока<code>un(event, [handler], [handlerCtx])</code>.</p><p><a name="bem-events-delegated"></a></p><h3 id="делегирование-bem-событий">Делегирование BEM-событий</h3><p>Делегирование BEM-событий означает, что блок подписывается наопределенное BEM-событие <strong>всех экземпляров</strong> блока с заданным именем<strong>в пределах заданного контекста</strong>. Подписка на делегированныеBEM-события выполняется с помощью статического метода <em>класса блока</em><code>on([ctx], event, [data], handler, [handlerCtx])</code>.</p><p>Параметры:</p><ul><li><code>{jQuery} [ctx]</code> &mdash; DOM-узел, в пределах которого отслеживаютсяBEM-события (контейнер). Если не указан, в качестве контейнераиспользуется весь документ.</li><li><code>{String} event</code> &mdash; имя BEM-события.</li><li><code>{Object} [data]</code> &mdash; произвольные данные, передаваемыефункции-обработчику.</li><li><code>{Function} handler</code> &mdash; функция-обработчик события.</li><li><code>{Object} [handlerCtx]</code> &mdash; контекст функции-обработчикасобытия. Обычно в качестве контекста должен выступать тот экземплярблока, который подписывается на BEM-событие, а не тот, в котором BEM-событиепроизошло.</li></ul><p><strong>Пример</strong>: При инициализации экземпляров блока <code>menu</code> выполняется  подписка на BEM-событие <code>click</code> всех ссылок (экземпляров блока  <code>link</code>) в пределах DOM-узла, к которому привязано меню  (<code>this.domElem</code>). В качестве контекста функции-обработчика  передается экземпляр блока, в котором событие будет обрабатываться  (<code>this</code>). При <a href="#destruct">уничтожении экземпляров блока</a> <code>menu</code></p><pre><code class="lang-js hljs actionscript">DOM.decl(<span class="hljs-string">&quot;menu&quot;</span>, {    onSetMod : {        <span class="hljs-string">&quot;js&quot;</span> : {            <span class="hljs-string">&quot;inited&quot;</span> : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>                DOM.blocks[<span class="hljs-string">&quot;link&quot;</span>].on( <span class="hljs-comment">// подписка на BEM-событие</span>                    <span class="hljs-keyword">this</span>.domElem, <span class="hljs-comment">// контейнер &mdash; DOM-узел экземпляра блока menu</span>                    <span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-comment">// BEM-событие</span>                    <span class="hljs-keyword">this</span>._onLinkClick, <span class="hljs-comment">// обработчик</span>                    <span class="hljs-keyword">this</span>); <span class="hljs-comment">// контекст обработчика &mdash; экземпляр блока menu</span>            },            <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>                DOM.blocks[<span class="hljs-string">&quot;link&quot;</span>].un( <span class="hljs-comment">// удаление подписки на BEM-событие</span>                    <span class="hljs-keyword">this</span>.domElem,                    <span class="hljs-string">&quot;click&quot;</span>,                    <span class="hljs-keyword">this</span>._onLinkClick,                    <span class="hljs-keyword">this</span>);            }        }    },    _onLinkClick : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> {</span>        <span class="hljs-keyword">var</span> clickedLink = e.target; <span class="hljs-comment">// экземпляр блока &quot;link&quot;, на котором произошло BEM-событие &quot;click&quot;</span>    }});</code></pre><hr><p><strong>NB:</strong> Если не указывать параметр <code>[handlerCtx]</code> метода <code>on</code>,  контекстом для функции-обработчика будет тот блок, в котором  <em>возникло</em> BEM-событие.</p><hr><p><strong>Удаление подписки</strong> на делегированные BEM-события никогда не  происходит автоматически. Всегда следует явно удалять подписку при  помощи статического метода блока <code>un([ctx], event, [handler],  [handlerCtx])</code>.</p><p>Полное описание API для работы с BEM-событиями содержится в исходномкоде модулей <a href="https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/i-bem.vanilla.js"><code>i-bem</code></a> и <a href="https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/__dom/i-bem__dom.js"><code>i-bem__dom</code></a>.</p><p><a name="api"></a></p><h2 id="объект-bem-события">Объект BEM-события</h2><p>В качестве параметра функции-обработчику передается объект,описывающий BEM-событие. Объект BEM-события <code>events.Event</code> определенв <a href="https://github.com/ymaps/modules">ymaps</a>-модуле<a href="https://github.com/bem/bem-core/blob/v1/common.blocks/events/events.vanilla.js"><code>events</code></a>библиотеки bem-core. Содержит поля:</p><ul><li><code>target</code> &mdash; экземпляр блока, в котором произошло BEM-событие.</li><li><code>data</code> &mdash; произвольные дополнительные данные. Передается в качествепараметра <code>data</code> в момент подписки на BEM-событие или при созданииBEM-события блоком.</li><li><code>result</code> &mdash; последнее значение, возвращенное обработчиком данногособытия. аналогично <a href="http://api.jquery.com/event.result/">jQuery.Event.result</a>.</li><li><code>type</code> &mdash; тип события. Аналогично<a href="http://api.jquery.com/event.type/">jQuery.Event.type</a>.</li></ul><p><a name="states"></a></p><h1 id="состояния-блока">Состояния блока</h1><p>Проектируя динамический блок в стиле БЭМ, нужно представить всю логикуизменений, происходящих в нем, как набор <strong>состояний</strong> блока. Тогдаповедение блока определяется <strong>триггерами</strong> &mdash; callback-функциями, которыевыполняются при переходе блока из одного состояния в другое.</p><p>Такой подход позволяет писать код блока в декларативном стиле какнабор утверждений вида: «описание состояния &mdash; действия, выполняемыепри переходе в данное состояние».</p><p><a name="modifiers"></a></p><h2 id="модификаторы">Модификаторы</h2><p>Согласно БЭМ-методологии, состояние блока и его элементов описывается<strong>модификаторами</strong>.</p><p>Модификатор описывает, в каком из возможных состояний находитсяблок. Модификатор представляет собой пару строк: <strong>имя</strong> и<strong>значение</strong>. Список допустимых значений модификатора описываетнабор состояний блока. Например, для описания размеров блока можноиспользовать модификатор <code>size</code> с допустимыми значениями <code>s</code>, <code>m</code> и<code>l</code>.</p><p><strong>Простой модификатор</strong> &mdash; частный случай, когда важно только наличиеили отсутствие данного модификатора у блока, а его значениенесущественно. Например, модификатор описывающий состояние «отключен»:<code>disabled</code>. В <em>i-bem.js</em> представлены как модификаторы с булевымзначением. При выставлении модификатора с неуказанным значением<em>i-bem.js</em> автоматически присваивает ему значение <code>true</code>.</p><p>Каждому блоку можно установить один или несколько модификаторов.  Блокможет не иметь модификаторов. Список допустимых модификаторов и ихзначений определяет разработчик блока.</p><p>В <em>i-bem.js</em> модификаторы устанавливаются при<a href="#init">инициализации экземпляра блока</a> (если модификаторы и ихзначения указаны в атрибуте <code>class</code> соответствующего HTML-элемента).</p><hr><p><strong>NB:</strong> Если модификаторы блока указаны в HTML-элементе, при  инициализации блока триггеры на установку данных модификаторов <em>не  выполняются</em>. Экземпляр блока в этом случае получает начальное  состояние, а не меняет его.</p><hr><p>Модификаторы могут добавляться, удаляться и менять значения:</p><ul><li>В ходе выполнения кода блока (например, в качестве реакции на <a href="#dom-events">DOM-события</a>).</li><li>По запросу из другого блока. Подробнее см. раздел <a href="#ibc">Взаимодействие блоков</a>.</li></ul><p>При добавлении, удалении и изменении значений модификаторов выполняются триггеры.</p><p><a name="mods-api"></a></p><h3 id="управление-модификаторами">Управление модификаторами</h3><p>Экземпляр блока предоставляет методы для установки, проверки значенийи удаления модификаторов данного экземпляра.</p><hr><p><strong>NB:</strong> Модификаторы нельзя устанавливать, напрямую меняя CSS-классы насоответствующем DOM-узле. Для изменения значений модификаторов следуетиспользовать описанный ниже API, предоставляемый <em>i-bem.js</em>.</p><hr><p><strong>Пример</strong>: Экземпляр блока <code>square</code> может по клику на DOM-элементеблока переключаться между значениями <code>green</code> и <code>red</code> модификатора<code>color</code>, если не выставлен модификатор <code>disabled</code>:</p><pre><code class="lang-js hljs actionscript">DOM.decl(<span class="hljs-string">&quot;square&quot;</span>, {    onSquareClick: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> {</span>        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.hasMod(<span class="hljs-string">&quot;disabled&quot;</span>)) {            <span class="hljs-keyword">this</span>.toggleMod(<span class="hljs-string">&quot;color&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>);        }    }});</code></pre><p>Эти же методы используются для управления модификаторами элементовблока. Для этого в качестве первого (необязательного) параметрауказывается ссылка на объект элемента (а не имя элемента).</p><p><strong>Пример</strong>: Блок <code>searchbox</code> по клику может выставлять своему элементу<code>input</code> простой модификатор <code>clean</code> (подразумеваемое значение &mdash;<code>true</code>):</p><pre><code class="lang-js hljs actionscript">DOM.decl(<span class="hljs-string">&quot;searchbox&quot;</span>, {    _onClick: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>        <span class="hljs-keyword">this</span>.setMod(<span class="hljs-keyword">this</span>.elem(<span class="hljs-string">&quot;input&quot;</span>), <span class="hljs-string">&quot;clean&quot;</span>);    }});</code></pre><hr><p><strong>NB:</strong> При управлении модификаторами элементов в качестве первого  параметра необходимо указывать ссылку на <strong>DOM-узел элемента</strong>, а не  имя элемента. В противном случае возникла бы неоднозначность:  имеется в виду установка блоку <em>модификатора</em> <code>input</code> со значением  <code>clean</code> или установка элементу <code>input</code> <em>простого модификатора</em> <code>clean</code>.</p><hr><p>Полное описание API для управления модификаторами приведено висходном коде модулей <a href="https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/i-bem.vanilla.js"><code>i-bem</code></a> и <a href="https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/__dom/i-bem__dom.js"><code>i-bem__dom</code></a>.</p><h2 id="триггеры-на-установку-модификаторов">Триггеры на установку модификаторов</h2><p>Выполнение триггеров на установку модификаторов разбито на две фазы:</p><ol><li><strong>До установки модификатора</strong>. Эта фаза зарезервирована длявозможности <strong>отменить</strong> установку модификатора. Если хотя бы одиниз триггеров, выполняемых в этой фазе, вернет <code>false</code>, установкимодификатора не произойдет.</li><li><strong>После установки модификатора</strong>. Триггеры, выполняемые в этойфазе, уже не могут отменить установку модификаторов.</li></ol><p>Триггеры могут быть привязаны к следующим типам изменений значений модификаторов:</p><ol><li>установка <em>любого</em> модификатора в <em>любое</em> значение;</li><li>установка <em>конкретного</em> модификатора <code>modName</code> в <em>любое</em> значение (в том числеустановка простого модификатора в значение <code>true</code>);</li><li>установка <em>конкретного</em> модификатора <code>modName</code> в <em>конкретное</em> значение <code>modVal</code>;</li><li>установка модификатора в значение <code>&quot;&quot;</code> (пустая строка), чтоэквивалентно удалению модификатора или установке простогомодификатора в значение <code>false</code>).</li></ol><p>При установке модификатора <code>modName</code> в значение <code>modVal</code> триггерыкаждой фазы (если они определены) вызываются в том порядке, в котором ониперечислены в приведенном выше списке событий (от общего к частному).</p><p>Таким образом, при определении триггера пользователь указывает:</p><ul><li>фазу выполнения (до или после установки модификатора);</li><li>тип события (имя и устанавливаемое значение модификатора).</li></ul><h3 id="декларация-триггеров">Декларация триггеров</h3><p>Триггеры, выполняемые при установке модификаторов, описываются вдекларации блока. Для этого в хэше методов экземпляра блоказарезервированы свойства:</p><ul><li><code>beforeSetMod</code> &mdash; триггеры, вызываемые до установки<strong>модификаторов блока</strong>.</li><li><code>beforeElemSetMod</code> &mdash; триггеры, вызываемые до установки<strong>модификаторов элементов</strong>.</li><li><code>onSetMod</code> &mdash; триггеры, вызываемые после установки<strong>модификаторов блока</strong>.</li><li><code>onElemSetMod</code> &mdash; триггеры, вызываемые после установки<strong>модификаторов элементов</strong> блока.</li></ul><pre><code class="lang-js hljs lasso">modules<span class="hljs-built_in">.</span><span class="hljs-class"><span class="hljs-keyword">define</span></span>(<span class="hljs-string">&quot;i-bem__dom&quot;</span>, function(<span class="hljs-keyword">provide</span>, DOM) {DOM<span class="hljs-built_in">.</span>decl(<span class="hljs-comment">/* селектор блока */</span>,    {        <span class="hljs-comment">/* методы экземпляра */</span>        beforeSetMod: { <span class="hljs-comment">/* триггеры до установки модификаторов блока*/</span>}        beforeElemSetMod: { <span class="hljs-comment">/* триггеры до установки модификаторов элементов*/</span>}        onSetMod: { <span class="hljs-comment">/* триггеры после установки модификаторов блока */</span> }        onElemSetMod: { <span class="hljs-comment">/* триггеры после установки модификаторов элементов */</span> }    },    {        <span class="hljs-comment">/* статические методы */</span>    });<span class="hljs-keyword">provide</span>(DOM);});</code></pre><p>Значение свойств <code>beforeSetMod</code> и <code>onSetMod</code> &mdash; хэш, связывающийизменения модификаторов с триггерами. В качестве параметров триггерампередаются:</p><ul><li>имя модификатора;</li><li>выставляемое значение модификатора;</li><li>предшествующее (для <code>beforeElemSetMod</code>) или текущее (для <code>onElemSetMod</code>) значение модификатора.</li></ul><pre><code class="lang-js hljs r">{    <span class="hljs-string">&quot;mod1&quot;</span>: <span class="hljs-keyword">function</span>(modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ }, // установка mod1 в любое значение    <span class="hljs-string">&quot;mod2&quot;</span>: {        <span class="hljs-string">&quot;val1&quot;</span>: <span class="hljs-keyword">function</span>(modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ }, // триггер на установку mod2 в значение val1        <span class="hljs-string">&quot;val2&quot;</span>: <span class="hljs-keyword">function</span>(modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ }, // триггер на установку mod2 в значение val2        <span class="hljs-string">&quot;&quot;</span>: <span class="hljs-keyword">function</span>(modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ } // триггер на удаление модификатора mod2    <span class="hljs-string">&quot;mod3&quot;</span>: {        <span class="hljs-string">&quot;true&quot;</span>: <span class="hljs-keyword">function</span>(modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ }, // триггер на установку простого модификатора mod3        <span class="hljs-string">&quot;&quot;</span>: <span class="hljs-keyword">function</span>(modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ }, // триггер на удаление простого модификатора mod3    },    <span class="hljs-string">&quot;*&quot;</span>: <span class="hljs-keyword">function</span>(modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ } // триггер на установку любого модификатора в любое значение}</code></pre><p>Для триггера на установку любого модификатора блока в любое значениесуществует сокращенная форма записи:</p><pre><code class="lang-js hljs r">beforeSetMod: <span class="hljs-keyword">function</span>(modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ }onSetMod: <span class="hljs-keyword">function</span>(modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ }</code></pre><p>Для свойств <code>beforeElemSetMod</code> и <code>onElemSetMod</code> в хэш значенийдобавляется дополнительный уровень вложенности &mdash; <strong>элемент</strong>. В этихсвойствах описываются триггеры на установку модификаторов элементов.В качестве параметров триггеру передаются:</p><ul><li>имя элемента;</li><li>имя модификатора;</li><li>выставляемое значение модификатора;</li><li>предшествующее (для <code>beforeElemSetMod</code>) или текущее (для <code>onElemSetMod</code>) значение модификатора.</li></ul><pre><code class="lang-js hljs r">{    <span class="hljs-string">&quot;elem1&quot;</span>: {        <span class="hljs-string">&quot;mod1&quot;</span>: <span class="hljs-keyword">function</span>(elem, modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ }, // триггер на установку mod1 элемента elem <span class="hljs-number">1</span> в любое значение        <span class="hljs-string">&quot;mod2&quot;</span>: {            <span class="hljs-string">&quot;val1&quot;</span>: <span class="hljs-keyword">function</span>(elem, modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ }, // триггер на установку mod2 элемента elem1 в значение val1            <span class="hljs-string">&quot;val2&quot;</span>: <span class="hljs-keyword">function</span>(elem, modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ } // триггер на установку mod2 элемента elem1 в значение val2            }        },    <span class="hljs-string">&quot;elem2&quot;</span>: <span class="hljs-keyword">function</span>(elem, modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ } // триггер на установку любого модификатора элемента elem2 в любое значение}</code></pre><p>Сокращенная запись для триггера на установку любого модификатора элемента<code>elem1</code> в любое значение:</p><pre><code class="lang-js hljs r">beforeElemSetMod: { <span class="hljs-string">&quot;elem1&quot;</span>: <span class="hljs-keyword">function</span>(elem, modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ } }onElemSetMod: { <span class="hljs-string">&quot;elem1&quot;</span>: <span class="hljs-keyword">function</span>(elem, modName, modVal, prevModVal) { /* <span class="hljs-keyword">...</span> */ } }</code></pre><h3 id="примеры-триггеров">Примеры триггеров</h3><p>Типовая задача триггеров, вызываемых после установки модификатора илиизменения его значения (свойство <code>onSetMod</code>) &mdash; выполнить операции надDOM-узлом блока, необходимые для перехода в новое состояние.</p><p><strong>Пример</strong>: Экземпляр блока <code>input</code> при установке простого  модификатора <code>focused</code> (в значение <code>true</code>) очищает поле ввода &mdash;  заменяет пустой строкой текст DOM-узла блока.</p><pre><code class="lang-js hljs actionscript">DOM.decl(<span class="hljs-string">&quot;input&quot;</span>, {    onSetMod : {        <span class="hljs-string">&quot;focused&quot;</span> : {            <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>                <span class="hljs-keyword">this</span>.domElem.val(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// очистить поле ввода</span>            }        }    }});</code></pre><p>Триггеры, выполняемые перед установкой модификатора (свойство<code>beforeSetMod</code>), необходимы для проверки текущего состояния экземпляраблока и возможности отменить переход в другое состояние.</p><p><strong>Пример</strong>: Экземпляр блока <code>input</code> перед установкой простого  модификатора <code>focused</code> проверяет, не выставлен ли у него модификатор  <code>disabled</code>. Если <code>disabled</code> выставлен, будет возвращено значение <code>false</code> и  установки модификатора <code>focused</code> не произойдет.</p><pre><code class="lang-js hljs actionscript">DOM.decl(<span class="hljs-string">&quot;input&quot;</span>, {    beforeSetMod : {        <span class="hljs-string">&quot;focused&quot;</span> : {            <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>                <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.hasMod(<span class="hljs-string">&quot;disabled&quot;</span>); <span class="hljs-comment">// вернет false, если disabled</span>            }        }    }});</code></pre><p><a name="init"></a></p><h2 id="инициализация">Инициализация</h2><p>Инициализация блока &mdash; это создание в памяти браузера JS-объекта,соответствующего экземпляру блока. Инициализация экземпляров блоков выполняетсяметодом <code>init()</code> модуля <code>i-bem__dom</code> на заданном фрагменте DOM-дерева.</p><p>Каждому экземпляру блока можно приписать три состояния:</p><ul><li>экземпляр блока не инициализирован (JS-объект не создан);</li><li>экземпляр блока инициализирован (JS-объект создан в памяти браузера);</li><li>экземпляр блока уничтожен (удалены все ссылки на JS-объект экземпляраблока и он может быть удален сборщиком мусора).</li></ul><p>В <em>i-bem.js</em> эти состояния экземпляра блока описываются с помощью служебногомодификатора <code>js</code>.</p><ul><li>До инициализации экземпляр блока не имеет модификатора <code>js</code>.</li></ul><pre><code class="lang-html hljs r">&lt;div class=<span class="hljs-string">"my-block i-bem"</span> data-bem=<span class="hljs-string">"..."</span> &gt;<span class="hljs-keyword">...</span>&lt;/div&gt;</code></pre><ul><li>В момент инициализации экземпляру блока устанавливается модификатор<code>js</code> в значении <code>inited</code>.</li></ul><pre><code class="lang-html hljs r">&lt;div class=<span class="hljs-string">"my-block i-bem my-block_js_inited"</span> data-bem=<span class="hljs-string">"..."</span>&gt;<span class="hljs-keyword">...</span>&lt;/div&gt;</code></pre><ul><li>Если в процессе работы удаляется фрагмент DOM-дерева (при помощиметода <code>destruct</code> модуля <code>i-bem__dom</code>) , то вместе сним удаляются экземпляры блоков, все HTML-элементы которых находятсяв этом фрагменте. Перед удалением экземпляра блока модификатор <code>js</code>удаляется.</li></ul><hr><p><strong>NB:</strong> Если экземпляр блока был  <a href="#distrib-block">привязан к нескольким HTML-элементам</a>, блок будет существовать,  пока в HTML-дереве сохраняется хотя бы один элемент, с которым он  связан.</p><hr><p>Если на HTML-элементе размещено несколько экземпляров других блоков, тоинициализация одного из них (появление модификатора <code>my-block_js_inited</code>)не влияет на инициализацию остальных.</p><p><strong>Пример</strong>: На HTML-элементе инициализирован только экземпляр блока <code>my-block</code>,экземпляр блока <code>lazy-block</code> не инициализирован:</p><pre><code class="lang-html hljs r">&lt;div class=<span class="hljs-string">"my-block my-block_js_inited lazy-block i-bem"</span>    data-bem=<span class="hljs-string">&quot;{ "my-block": {}, "lazy-block": {} }&quot;</span> &gt;    <span class="hljs-keyword">...</span>&lt;/div&gt;</code></pre><hr><p><strong>NB:</strong> Наличие модификатора <code>js</code> позволяет писать разные CSS-стили для  блока в зависимости от того, инициализирован он или нет.</p><hr><h3 id="конструктор-экземпляра-блока">Конструктор экземпляра блока</h3><p>На изменение значений модификатора <code>js</code> можно назначать триггеры также, как и для любых других модификаторов блока.</p><p>Триггер на установку модификатора <code>js</code> в значение <code>inited</code> выполняетсяпри создании блока. Этот триггер можно считать <strong>конструкторомэкземпляра блока</strong>:</p><pre><code class="lang-js hljs r">onSetMod: {    <span class="hljs-string">&quot;js&quot;</span>: {        <span class="hljs-string">&quot;inited&quot;</span>: <span class="hljs-keyword">function</span>() { /* <span class="hljs-keyword">...</span> */ } // конструктор экземпляра блока    }}</code></pre><p><a name="destruct"></a></p><h3 id="деструктор-экземпляра-блока">Деструктор экземпляра блока</h3><p>Моментом удаления блока является момент уничтожения всех ссылок наJS-объект блока, после чего он может быть удален из памяти браузерасборщиком мусора.</p><p>Триггер на удаление модификатора <code>js</code> (установку в пустое значение<code>&quot;&quot;</code>) выполняется перед удалением блока. Такой триггер можно считать<strong>деструктором экземпляра блока</strong>.</p><pre><code class="lang-js hljs r">onSetMod: {    <span class="hljs-string">&quot;js&quot;</span>: {        <span class="hljs-string">&quot;&quot;</span>: <span class="hljs-keyword">function</span>() { /* <span class="hljs-keyword">...</span> */ } // деструктор экземпляра блока    }}</code></pre><p><a name="init-wave"></a></p><h3 id="волны-инициализации">Волны инициализации</h3><p>Инициализация экземпляров блоков, присутствующих на странице, необязательно происходит одновременно. Блоки могут добавляться в ходеработы (например, за счет динамической генерации HTML на основеданных, полученных от сервера) или инициализироваться только по запросу.Инициализация очередной группы блоков называется <strong>волнойинициализации</strong>.</p><p>Новая волна инициализации создается в следующих случаях:</p><ul><li><a href="#init-auto">Автоматическая инициализация всех блоков в документе по событию <code>domReady</code></a>;</li><li><a href="#init-live">Инициализация блока по событию на DOM-узле</a> (ленивая инициализация);</li><li><a href="#init-ajax">Явный вызов инициализации блоков на указанном фрагменте DOM-дерева</a>.</li></ul><p><a name="init-auto"></a></p><h3 id="автоматическая-инициализация">Автоматическая инициализация</h3><p>Фреймворк <em>i-bem.js</em> позволяет автоматически инициализировать всеблоки, имеющие DOM-представление (привязанные к DOM-элементам настранице) в момент наступления DOM-события <code>domReady</code>. Чтобы включитьавтоматическую инициализацию, необходимо задекларировать на страницеблок <code>i-bem</code> с модификатором <code>init</code> в значении <code>auto</code>. Пример файла<code>.deps.js</code>:</p><pre><code class="lang-js hljs css">(<span class="hljs-rules">{    <span class="hljs-rule"><span class="hljs-attribute">shouldDeps</span>:<span class="hljs-value"> [        {            block: <span class="hljs-string">&quot;i-bem&quot;</span>,            elem: <span class="hljs-string">&quot;dom&quot;</span>,            mods: { <span class="hljs-string">&quot;init&quot;</span>: <span class="hljs-string">&quot;auto&quot;</span> </span></span></span>}        }    ]})</code></pre><p>При автоматической инициализации в памяти браузера будут созданыJS-объекты для всех DOM-узлов, в атрибуте <code>class</code> которых указан<code>i-bem</code>. Инициализация выполняется функцией <code>init</code> модуля<a href="https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/__dom/i-bem__dom.js"><code>i-bem__dom</code></a>.</p><p><a name="init-live"></a></p><h3 id="инициализация-по-событию--ленивая-инициализация-">Инициализация по событию (ленивая инициализация)</h3><p>Если на странице размещено много экземпляров блоков, автоматическая инициализациявсех блоков в момент загрузки страницы нежелательна, так как онаувеличивает время загрузки и объем памяти, затрачиваемой браузером.</p><p>В этом случае имеет смысл инициализировать JS-объектытолько в тот момент, когда их функциональность потребуетсяпользователю, например, по клику на блоке. Такая инициализацияназывается <strong>ленивой</strong> или <strong>live-инициализацией</strong>.</p><p>Для описания условий ленивой инициализации зарезервировано свойство<code>live</code> в разделе статических методов декларации блока. Свойство <code>live</code>может принимать два типа значений:</p><ul><li><code>Boolean</code>.<br> Имеет смысл только значение <code>true</code>: экземплярыблоков данного класса будут инициализированы только при попыткеполучить соответствующий экземпляр. Подробнеесм. раздел <a href="#ibc">Взаимодействие блоков</a>.</li></ul><pre><code class="lang-js hljs r">modules.define(<span class="hljs-string">&quot;i-bem__dom&quot;</span>, <span class="hljs-keyword">function</span>(provide, DOM) {DOM.decl(<span class="hljs-string">&quot;my-block&quot;</span>,    {        onSetMod: {            <span class="hljs-string">&quot;js&quot;</span>: {                <span class="hljs-string">&quot;inited&quot;</span>: <span class="hljs-keyword">function</span>() { /* <span class="hljs-keyword">...</span> */ } // этот код будет выполняться                                                   // при первом обращении к экземпляру блока            }        }    },    { live: <span class="hljs-string">&quot;true&quot;</span> } // статические методы и свойства);provide(DOM);});</code></pre><ul><li><code>Function</code>.<br> Функция, которую нужно выполнить при попытке  инициализации <strong>первого экземпляра</strong> блока заданного класса.  Если  функция возвращает значение <code>false</code>, экземпляры блоков будут  инициализироваться <a href="#init-auto">автоматически</a>.</li></ul><p>Если необходимо инициализировать экземпляры блока по наступлениюDOM- или BEM-событий, в теле функции следует выполнить подписку на<a href="#delegated-events">делегированные события</a>. Возможна инициализацияпо:</p><ul><li>DOM-событию на DOM-узле блока и вложенных элементах;</li><li>BEM-событию на вложенных блоках.</li></ul><p><strong>Пример</strong>: Экземпляры блока <code>my-block</code> будут инициализироваться по  DOM-событию <code>click</code> на DOM-узле блока. По каждому DOM-событию  <code>click</code> будет вызываться метод экземпляра блока <code>_onClick</code>:</p><pre><code class="lang-js hljs r">modules.define(<span class="hljs-string">&quot;i-bem__dom&quot;</span>, <span class="hljs-keyword">function</span>(provide, DOM) {DOM.decl(<span class="hljs-string">&quot;my-block&quot;</span>,    {        onSetMod: {            <span class="hljs-string">&quot;js&quot;</span>: {                <span class="hljs-string">&quot;inited&quot;</span>: <span class="hljs-keyword">function</span>() { /* <span class="hljs-keyword">...</span> */ } // выполняется при первом DOM-событии <span class="hljs-string">&quot;click&quot;</span>            }        },        _onClick: <span class="hljs-keyword">function</span>() { /* <span class="hljs-keyword">...</span> */ } // выполняется при каждом DOM-событии <span class="hljs-string">&quot;click&quot;</span>    },    {        live: <span class="hljs-keyword">function</span>() {            this.liveBindTo(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>() {                this._onClick(); // в момент клика будет создан экземпляр блока и вызван его метод _onClick            });        }    });provide(DOM);});</code></pre><p>Если необходимо воспользоваться делегированными событиями в блоке, ноинициализацию блока нельзя отложить (экземпляры блока должны бытьинициализированы немедленно после загрузки страницы), следует вернутьзначение <code>false</code>:</p><pre><code class="lang-js hljs r">modules.define(<span class="hljs-string">&quot;i-bem__dom&quot;</span>, <span class="hljs-keyword">function</span>(provide, DOM) {DOM.decl(<span class="hljs-string">&quot;my-block&quot;</span>,    {        onSetMod: {            <span class="hljs-string">&quot;js&quot;</span>: {                <span class="hljs-string">&quot;inited&quot;</span>: <span class="hljs-keyword">function</span>() { /* <span class="hljs-keyword">...</span> */ } // будет выполнена по наступлении domReady            }        },        _onClick: <span class="hljs-keyword">function</span>() { /* <span class="hljs-keyword">...</span> */ } // будет выполняться каждый                                           // раз при наступлении DOM-события <span class="hljs-string">&quot;click&quot;</span>    },    {        live: <span class="hljs-keyword">function</span>() {            this.liveBindTo(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>() { this._onClick() });            <span class="hljs-keyword">return</span> false; // экземпляры блоков будут инициализированы автоматически        }    });provide(DOM);});</code></pre><p>Полный список хелперов для подписки на делегированные событияприведен в исходном коде модуля <a href="https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/__dom/i-bem__dom.js"><code>i-bem__dom</code></a>.</p><hr><p><strong>NB:</strong> Свойство <code>live</code> задает ленивую инициализацию для <em>всех  экземпляров</em> соответствующего блока, так как технически относится к  статическим методам класса блока. Поэтому даже если свойство <code>live</code>  задекларировано для блока с определенным значением модификатора, оно  будет применено ко всем блокам данного класса вне зависимости от  модификаторов.</p><hr><p><a name="init-ajax"></a></p><h3 id="инициализация-и-удаление-блоков-на-фрагменте-dom-дерева">Инициализация и удаление блоков на фрагменте DOM-дерева</h3><p>Процедура инициализации или уничтожения JS-объектов может быть вызванаявно для указанного фрагмента DOM-дерева. Часто такая необходимостьвозникает при разработке AJAX-интерфейсов, когда нужно <a href="#dynamic">динамическивстроить в страницу новые экземпляры блоков</a> либо обновить существующие.</p><p>В <em>i-bem.js</em> следующие функции выполняют динамическую инициализацию блоков:</p><ul><li>Инициализация/уничтожение блоков на указанном фрагменте DOM-дерева(<code>init</code>, <code>destruct</code>);</li><li>Добавление/замена фрагмента DOM-дерева с одновременнойинициализацией блоков на обновленном фрагменте (<code>update</code>, <code>replace</code>,<code>append</code>, <code>prepend</code>, <code>before</code>, <code>after</code>).</li></ul><p><a name="init-bem"></a></p><h3 id="инициализация-и-удаление-блоков-без-dom-представления">Инициализация и удаление блоков без DOM-представления</h3><p>Чтобы создать JS-объект для блока, не имеющего DOM-представления (непривязанного к HTML-элементу), необходимо вызвать метод <code>create</code>,который вернет экземпляр блока указанного класса.</p><p><strong>Пример</strong>: В момент инициализации экземпляра блока с DOM-представлением  <code>container</code> создается экземпляр блока без DOM-представления <code>router</code>. Экземпляр блока  <code>container</code> затем будет обращаться к созданному им экземпляру блока  <code>router</code> при вызове метода <code>onRequest</code>:</p><pre><code class="lang-js hljs actionscript">modules.define(<span class="hljs-string">&quot;i-bem__dom&quot;</span>, <span class="hljs-string">&quot;i-bem&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, BEM, DOM)</span> {</span>DOM.decl(<span class="hljs-string">&quot;container&quot;</span>, {    onSetMod: {        <span class="hljs-string">&quot;js&quot;</span>: {            <span class="hljs-string">&quot;inited&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>                <span class="hljs-keyword">this</span>._router = BEM.create(<span class="hljs-string">&quot;router&quot;</span>); <span class="hljs-comment">// создание экземпляра блока router</span>            }        }    },    onRequest: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>        <span class="hljs-keyword">this</span>._router.route(<span class="hljs-comment">/* ... */</span>) <span class="hljs-comment">// вызов метода экземпляра блока router</span>    }});provide(DOM);});</code></pre><p><strong>Пример</strong>: Блок без DOM-представления реализован в виде простого  <a href="https://github.com/ymaps/modules">ymaps-модуля</a>, без использования модуля <code>i-bem</code>. Такой блок  используется как обычный ymaps-модуль (нет необходимости создавать  экземпляр блока):</p><pre><code class="lang-js hljs r">modules.define(<span class="hljs-string">&quot;i-bem__dom&quot;</span>, <span class="hljs-string">&quot;router&quot;</span>, <span class="hljs-keyword">function</span>(provide, DOM, router) {DOM.decl(<span class="hljs-string">&quot;container&quot;</span>, {    onRequest: <span class="hljs-keyword">function</span>() {        router.route(/* <span class="hljs-keyword">...</span> */); // вызов метода блока router    }});provide(DOM, router);});</code></pre><p><strong>Удаление</strong> экземпляров блоков без DOM-представления не может бытьвыполнено автоматически и является ответственностьюразработчика. Блоки без DOM-представления представляют собой обычныеJS-объекты и удаляются в момент удаления всех ссылок на объект блока.</p><p><strong>Пример</strong>: При удалении экземпляра блока <code>container</code> удаляется созданный им впроцессе работы экземпляр блока без DOM-представления <code>router</code>.</p><pre><code class="lang-js hljs actionscript">modules.define(<span class="hljs-string">&quot;i-bem__dom&quot;</span>, <span class="hljs-string">&quot;i-bem&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, BEM, DOM)</span> {</span>DOM.decl(<span class="hljs-string">&quot;container&quot;</span>, {    onSetMod : {        <span class="hljs-string">&quot;js&quot;</span> : {            <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._router; <span class="hljs-comment">// удаление экземпляра блока router</span>            }        }    }});provide(DOM);});</code></pre><p><a name="ibc"></a></p><h1 id="взаимодействие-блоков">Взаимодействие блоков</h1><p>В рамках БЭМ-методологии блоки следует разрабатывать так,чтобы по возможности исключить зависимость состояний однихблоков от других. Однако на практике идеал полной независимости блоковнедостижим.</p><p>Взаимодействие блоков может быть реализовано двумя способами:</p><ul><li>С помощью подписки на <a href="#bem-events">BEM-события</a> других экземпляровблоков или подписки на <a href="#bem-events-delegated">делегированные BEM-события</a>.</li><li>С помощью непосредственного вызова методов других экземпляровблоков или статических методов класса другого блока.</li></ul><hr><p><strong>NB:</strong> Не используйте <a href="#dom-events">DOM-события</a> для  организации взаимодействия между блоками. DOM-события предназначены  только для реализации внутренних процедур блока.</p><hr><p>Для реализации взаимодействия блоков <em>i-bem.js</em> предоставляет API:</p><ul><li><a href="#api-find">Поиск экземпляров блоков в DOM-дереве</a>;</li><li><a href="#api-nodom">Доступ к экземплярам блоков без DOM-представления</a>;</li><li><a href="#api-calss">Доступ к классам блоков</a>.</li></ul><p><a name="api-find"></a></p><h2 id="поиск-экземпляров-блоков-в-dom-дереве">Поиск экземпляров блоков в DOM-дереве</h2><p>Обращение к другому блоку в <em>i-bem.js</em> выполняется из текущего блока,размещенного на определенном узле DOM-дерева. Поиск других блоков вDOM-дереве может вестись по трем направлениям (осям) относительноDOM-узла текущего блока:</p><ul><li>«Внутри блока» &mdash; на DOM-узлах, вложенных в DOM-узел текущего блока.</li><li>«Снаружи блока» &mdash; на DOM-узлах, потомком которых является DOM-узелтекущего блока. Необходимость в таком поиске может свидетельствоватьо неудачной архитектуре интерфейса.</li><li>«На себе» &mdash; на том же DOM-узле, на котором размещен текущийблок. Это актуально в случае <a href="#html-mixes">размещения нескольких JS-блоков наодном DOM-узле</a> (микс).</li></ul><p><strong>Пример</strong>: При переключении модификатора <code>disabled</code> экземпляр блока  <code>attach</code> находит вложенный в него блок <code>button</code> и переключает его  модификатор <code>disabled</code> в то же значение, которое получил сам:</p><pre><code class="lang-js hljs actionscript">modules.define(<span class="hljs-string">&quot;i-bem__dom&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(provide, DOM)</span> {</span>DOM.decl(<span class="hljs-string">&quot;attach&quot;</span>, {    onSetMod: {        <span class="hljs-string">&quot;disabled&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(modName, modVal)</span> {</span>            <span class="hljs-keyword">this</span>.findBlockInside(<span class="hljs-string">&quot;button&quot;</span>).setMod(modName, modVal);        }    }});provide(DOM);});</code></pre><p>Полный список методов для поиска блоков блоков приведенв исходном коде модуля <a href="https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/__dom/i-bem__dom.js"><code>i-bem__dom</code></a>.</p><hr><p><strong>NB:</strong> Не используйте jQuery-селекторы для поиска блоков и элементов.<em>i-bem.js</em> предоставляет высокоуровневое API для доступа к DOM-узламблоков и элементов. Обращение к DOM-дереву в обход этого API делаеткод менее устойчивым к изменениям БЭМ-библиотек и может привести квозникновению сложно обнаруживаемых ошибок.</p><hr><p><a name="api-nodom"></a></p><h2 id="доступ-к-экземплярам-блоков-без-dom-представления">Доступ к экземплярам блоков без DOM-представления</h2><p>При создании экземпляра блока без DOM-представления необходимопозаботиться о том, чтобы ссылка на этот экземпляр была доступнаблокам, которым потребуется взаимодействовать с ним. Подробности ипример см. в разделе <a href="#init-bem">Инициализация и удаление блоков без DOM-представления</a>.</p><p><a name="api-class"></a></p><h2 id="доступ-к-классам-блоков">Доступ к классам блоков</h2><p>JS-компоненты, соответствующие всем блокам («классы» блоков), хранятсяв структуре данных <code>BEM.blocks</code>. Классы блоков,<a href="#i-blocks">не привязанных к DOM-дереву</a>, также размещены в этойструктуре данных. При необходимости доступа к таким блокам следуетиспользовать конструкцию:</p><pre><code class="lang-js hljs scilab"><span class="hljs-transposed_variable">BEM.</span>blocks<span class="hljs-matrix">[<span class="hljs-string">&quot;name&quot;</span>]</span></code></pre><p>где <code>name</code> &mdash; имя блока.</p><p>Доступ к классам блоков необходим для решения двух основных задач:</p><ul><li><a href="#bem-events-delegated">Делегирование БЭМ-событий</a>.</li><li>Вызов статического метода класса.</li></ul><p><strong>Пример</strong>: Вызов статического метода <code>close</code> блока <code>popup</code> &mdash; закрыть  все попапы на странице:</p><pre><code class="lang-js hljs scilab"><span class="hljs-transposed_variable">DOM.</span>decl(<span class="hljs-string">&quot;switcher&quot;</span>, {    onSetMod : {        <span class="hljs-string">&quot;popup&quot;</span> : {            <span class="hljs-string">&quot;disabled&quot;</span> : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>                <span class="hljs-transposed_variable">BEM.</span>blocks<span class="hljs-matrix">[<span class="hljs-string">&quot;popup&quot;</span>].</span>close();            }        }    }});</code></pre><p><a name="docs"></a></p><h1 id="что-дальше-">Что дальше?</h1><p>Общую информацию о БЭМ-методологии, инструментарии, новостях в миреБЭМ можно найти на сайте <a href="http://ru.bem.info/">bem.info</a>.</p><p>Полную информацию обо всех методах API <em>i-bem.js</em> можно найти висходном коде, который сопровождается структурированными комментариямив формате JSDoc:</p><ul><li><a href="https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/i-bem.vanilla.js"><code>i-bem</code></a>;</li><li><a href="https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/__dom/i-bem__dom.js"><code>i-bem__dom</code></a>.</li></ul><p>Задать вопрос опытным пользователям и разработчикам <em>i-bem.js</em> иследить за текущими обсуждениями можно в социальных сетях:</p><ul><li><a href="http://clubs.ya.ru/bem/">Клуб в Я.ру</a>;</li><li><a href="http://www.facebook.com/#!/groups/209713935765634/">Группа в Facebook</a>;</li><li><a href="https://twitter.com/bem_ru">Twitter</a>.</li></ul><p>Прочитать о принципах работы <em>i-bem.js</em> в другом изложении, найтиобразцы его применения и пошаговые инструкции на примере простыхпроектов можно в статьях:</p><ul><li><a href="http://ru.bem.info/articles/bem-js-main-terms/">JavaScript по БЭМ: основные понятия</a>;</li><li><a href="https://github.com/varya/bem-js-tutorial">Tutorial on JavaScript in BEM terms</a>;</li><li><a href="http://habrahabr.ru/post/162385/">Попробуй БЭМ на вкус!</a>;</li><li><a href="http://ru.bem.info/articles/firm-card-story/">БЭМ-приложение на Leaflet и API 2GIS</a>.</li></ul><hr><p><strong>NB:</strong> Обратите внимание, что в перечисленных статьях можетиспользоваться устаревший синтаксис, не соответствующий текущей версии<em>i-bem.js</em>, включенной в bem-core.</p><hr></div><div class="post__issue"><span>Если вы заметили ошибку или хотите чем-то дополнить статью, вы всегда можете или </span><a href="https://github.com/bem/bem-core/issues/new?title=Feedback+for+&quot;i-bem.js: Руководство пользователя&quot;" data-bem="{&quot;link&quot;:{}}" class="link link__control i-bem">написать об этом</a><span> на Гитхабе</span><span>, или </span><a href="http://prose.io/#bem/bem-core/edit/v2.2.0/common.docs/i-bem-js/i-bem-js.ru.md" data-bem="{&quot;link&quot;:{}}" class="link link__control i-bem">поправить статью</a><span> с помощью prose.io.</span></div><script charset="utf-8" src="//yastatic.net/share/share.js"></script><div class="likes"><div class="likes__text">Поделиться c миром:</div><div data-yashareimage="http://avatars.yandex.net/get-yaevents/fbd94638d43ccf96eb203538181f8897/150x150" data-yasharetype="small" data-yasharetheme="counter" data-yasharetitle="BEM - i-bem.js: Руководство пользователя" data-yasharequickservices="yaru,vkontakte,twitter,facebook" data-yasharel10n="ru" class="likes__buttons yashare-auto-init b-share_theme_counter" data-yasharelink="http://ru.localhost:3015/libs/bem-core/2.2.0/i-bem-js/i-bem-js/"><span class="b-share b-share_type_small"><span class="b-share-btn__wrap"><a data-service="vkontakte" href="http://share.yandex.ru/go.xml?service=vkontakte&amp;url=http%3A%2F%2Fru.localhost%3A3015%2Flibs%2Fbem-core%2F2.2.0%2Fi-bem-js%2Fi-bem-js%2F&amp;title=BEM%20-%20i-bem.js%3A%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F&amp;image=http%3A%2F%2Favatars.yandex.net%2Fget-yaevents%2Ffbd94638d43ccf96eb203538181f8897%2F150x150" class="b-share__handle b-share__link b-share-btn__vkontakte" title="ВКонтакте" target="_blank" rel="nofollow"><span class="b-share-icon b-share-icon_vkontakte"></span><span class="b-share-counter"></span></a></span><span class="b-share-btn__wrap"><a data-service="twitter" href="http://share.yandex.ru/go.xml?service=twitter&amp;url=http%3A%2F%2Fru.localhost%3A3015%2Flibs%2Fbem-core%2F2.2.0%2Fi-bem-js%2Fi-bem-js%2F&amp;title=BEM%20-%20i-bem.js%3A%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F&amp;image=http%3A%2F%2Favatars.yandex.net%2Fget-yaevents%2Ffbd94638d43ccf96eb203538181f8897%2F150x150" class="b-share__handle b-share__link b-share-btn__twitter" title="Twitter" target="_blank" rel="nofollow"><span class="b-share-icon b-share-icon_twitter"></span><span class="b-share-counter"></span></a></span><span class="b-share-btn__wrap"><a data-service="facebook" href="http://share.yandex.ru/go.xml?service=facebook&amp;url=http%3A%2F%2Fru.localhost%3A3015%2Flibs%2Fbem-core%2F2.2.0%2Fi-bem-js%2Fi-bem-js%2F&amp;title=BEM%20-%20i-bem.js%3A%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8F&amp;image=http%3A%2F%2Favatars.yandex.net%2Fget-yaevents%2Ffbd94638d43ccf96eb203538181f8897%2F150x150" class="b-share__handle b-share__link b-share-btn__facebook" title="Facebook" target="_blank" rel="nofollow"><span class="b-share-icon b-share-icon_facebook"></span><span class="b-share-counter"></span></a></span><iframe src="//yastatic.net/share/ya-share-cnt.html?url=http%3A%2F%2Fru.localhost%3A3015%2Flibs%2Fbem-core%2F2.2.0%2Fi-bem-js%2Fi-bem-js%2F&amp;services=yaru,vkontakte,twitter,facebook" style="display: none"></iframe></span></div></div></div></div>'
                            }
                        ]
                    }
                ]
            }
        },
        {
            block : 'footer',
            content : [
                'footer content goes here'
            ]
        }
    ]
})
